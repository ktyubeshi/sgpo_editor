---
created: 2025-03-12T16:43
updated: 2025-03-12T16:43
---
# SGPO Editor アーキテクチャ設計

## 1. アーキテクチャ概要

SGPO Editorは、Model-View-Controller (MVC) アーキテクチャパターンに基づいて設計されています。このパターンにより、データ処理（Model）、ユーザーインターフェース（View）、およびビジネスロジック（Controller）の分離が実現され、コードの保守性と拡張性が向上しています。

### 主要コンポーネント

```
┌────────────────────┐      ┌────────────────────┐      ┌────────────────────┐
│                    │      │                    │      │                    │
│       Model        │◄────►│     Controller     │◄────►│        View        │
│                    │      │                    │      │                    │
└────────────────────┘      └────────────────────┘      └────────────────────┘
        │                           │                           │
        ▼                           ▼                           ▼
┌────────────────────┐      ┌────────────────────┐      ┌────────────────────┐
│                    │      │                    │      │                    │
│   POファイルデータ    │      │    イベント処理     │      │     UI コンポーネント  │
│                    │      │                    │      │                    │
└────────────────────┘      └────────────────────┘      └────────────────────┘
```

## 2. レイヤー構成

SGPOエディタは以下の主要レイヤーで構成されています：

### プレゼンテーション層（GUI）
- ユーザーインターフェースコンポーネント
- イベント処理
- ビューの管理

### ビジネスロジック層
- POファイル操作
- フィルタリング
- 検索
- 統計計算

### データアクセス層
- POファイルの読み込み/保存
- エントリデータの管理

### 共通・ユーティリティ層
- 共通関数
- ヘルパーユーティリティ
- ロギング

## 3. コンポーネント詳細

### 3.1 モデルコンポーネント

#### PoFile クラス
POファイルのデータモデルを表現し、ファイルの読み込み、保存、および操作機能を提供します。

```python
class PoFile:
    """POファイルを扱うクラス"""
    
    def __init__(self, file_path: str | Path):
        self.file_path = Path(file_path)
        self.po = sgpo.pofile(str(self.file_path))
        self._modified = False
    
    def save(self, file_path: str | Path | None = None) -> None:
        """POファイルを保存する"""
        # 実装詳細...
```

#### ViewerPOFile クラス
UIと連携するためのPOファイル表示モデル。エントリのフィルタリングや検索機能を提供します。

**注: 現在のViewerPOFileクラスは、ファイル読み込み、データベース操作、フィルタリング、キャッシュ管理など多くの責務を持っています。将来のリファクタリングでは、以下のように責務を分割することを検討しています：**

```
┌────────────────────────┐      ┌────────────────────────┐
│     ViewerPOFile       │      │    EntryCacheManager   │
│ (UIとデータの連携管理)   │◄────►│  (キャッシュ戦略の実装)  │
└────────────────────────┘      └────────────────────────┘
            │                               │
            ▼                               ▼
┌────────────────────────┐      ┌────────────────────────┐
│   DatabaseAccessor     │      │   InMemoryEntryStore   │
│  (データベース操作)      │◄────►│ (インメモリキャッシュDB) │
└────────────────────────┘      └────────────────────────┘
```

#### データベースコンポーネント

##### InMemoryEntryStore (Database) クラス
ViewerPOFileの内部キャッシュとして機能する、インメモリSQLiteデータベースを提供します。アプリケーション終了時にデータは消失し、永続化はPOファイルへの保存で行われます。フィルタリングとソートのためのクエリ機能を提供します。

```python
class Database:  # 将来的にInMemoryEntryStoreに改名予定
    """インメモリSQLiteデータベースを使用したデータストア"""
    
    def __init__(self):
        self.conn = sqlite3.connect(":memory:")
        self._create_tables()
    
    def add_entries(self, entries: list):
        """エントリをデータベースに追加"""
        # 実装詳細...
```

##### EvaluationDatabase クラス
LLM評価データを永続化するためのサイドカーデータベース。POファイルと同じディレクトリに.evaldb拡張子で保存され、アプリケーション再起動後も評価データを保持します。

```python
class EvaluationDatabase:
    """LLM評価データを永続化するサイドカーデータベース"""
    
    def __init__(self, po_file_path: str | Path):
        self.db_path = Path(str(po_file_path) + ".evaldb")
        self.conn = sqlite3.connect(str(self.db_path))
        # 実装詳細...
```

### 3.2 ビューコンポーネント

#### MainWindow クラス
アプリケーションのメインウィンドウを表現し、他のすべてのUIコンポーネントを統合します。

```python
class MainWindow(QMainWindow):
    """メインウィンドウ"""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        # コンポーネントの初期化...
```

#### TableManager クラス
POエントリテーブルの表示と管理を担当します。

#### EntryEditor クラス
選択されたPOエントリの編集インターフェースを提供します。

#### StatsWidget クラス
翻訳の統計情報を表示します。

#### SearchWidget クラス
検索とフィルタリング機能を提供します。

### 3.3 コントローラーコンポーネント

#### FileHandler クラス
ファイル操作（開く、保存、新規作成）を処理します。

```python
class FileHandler:
    """ファイル操作を担当するハンドラクラス"""
    
    def __init__(self, parent):
        """初期化"""
        self.parent = parent
        self.current_po = None
        self.file_path = None
```

#### EventHandler クラス
ユーザーインターフェースイベントの処理を担当します。

#### UIManager クラス
レイアウトと表示の管理を担当します。

## 4. データフロー

### 4.1 POファイルを開く
1. ユーザーが「ファイルを開く」アクションを実行
2. FileHandlerがダイアログを表示してファイル選択を処理
3. 選択されたファイルがPoFileクラスを通じて読み込まれる
4. データがViewerPOFileに変換される
5. TableManagerがテーブルを更新
6. StatsWidgetが統計情報を更新

### 4.2 エントリの編集
1. ユーザーがテーブルでエントリを選択
2. 選択されたエントリがEntryEditorに表示される
3. ユーザーがエントリを編集し保存する
4. EntryEditorがデータをPoFileモデルに反映
5. TableManagerがテーブルを更新
6. StatsWidgetが統計情報を更新

### 4.3 検索とフィルタリング
1. ユーザーが検索条件を入力
2. SearchWidgetがイベントを発行
3. MainWindowが検索条件を取得してViewerPOFileに渡す
4. ViewerPOFileがフィルタリングされたエントリのリストを返す
5. TableManagerがテーブルを更新

## 5. コンポーネント間の依存関係

```
     ┌───────────────────┐
     │    MainWindow     │
     └───────────────────┘
            │   │   │
     ┌──────┘   │   └──────┐
     ▼           ▼          ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│FileHandler│ │UIManager│ │EventHandler│
└─────────┘ └─────────┘ └─────────┘
     │           │          │
     └───────────┼──────────┘
                 ▼
          ┌───────────────┐
          │  ViewerPOFile  │
          └───────────────┘
                  │
                  ▼
            ┌───────────┐
            │   PoFile   │
            └───────────┘
```

## 6. エラー処理戦略

SGPO Editorでは、以下のエラー処理戦略を採用しています：

1. **例外処理**: 適切なtry-except構文を使用して、予期せぬエラーを処理
2. **ユーザーフレンドリーなエラーメッセージ**: 技術的なエラーを一般ユーザーが理解できるメッセージに変換
3. **ロギング**: デバッグや問題解決のためのエラーログ記録
4. **グレースフルデグラデーション**: 機能の一部が失敗しても、アプリケーション全体はできるだけ動作を継続

## 7. スケーラビリティと拡張性

SGPO Editorは以下の方法で拡張性を確保しています：

1. **モジュラー設計**: 機能ごとに分離されたモジュール構成
2. **インターフェース分離**: 実装の詳細からインターフェースを分離
3. **設定可能なコンポーネント**: カスタマイズや拡張が可能な設計
4. **プラグインアーキテクチャ**: 将来的なプラグインシステムのための基盤

## 8. パフォーマンスと最適化

### 8.1 キャッシュ戦略

SGPO Editorは以下のキャッシュ戦略を採用しています：

1. **インメモリデータベース**: POファイルのエントリは、高速なフィルタリングとソートのためにSQLiteインメモリデータベースにロードされます。
2. **オブジェクトキャッシュ**: 頻繁にアクセスされるEntryModelオブジェクトはメモリにキャッシュされ、再利用されます。
3. **プリフェッチ**: ユーザーの操作パターンを予測し、次に表示される可能性が高いエントリを事前にロードします。
4. **キャッシュ無効化メカニズム**: データが更新された場合、関連するキャッシュを無効化するフラグシステムを使用します。

### 8.2 非同期処理

UIの応答性を維持するため、時間のかかる処理は非同期で実行されます：

1. **LLM評価**: 大規模言語モデルを使用した翻訳品質評価は、バックグラウンドスレッドで実行されます。
2. **大規模ファイルの読み込み**: 大きなPOファイルの読み込みは非同期で行われ、進捗状況が表示されます。
3. **進捗通知**: 非同期タスクはシグナル/スロットメカニズムを使用して進捗と完了を通知します。

```python
# 非同期処理の例
class LLMEvaluationWorker(QRunnable):
    """LLM評価を非同期で実行するワーカークラス"""
    
    def __init__(self, entry, api_key):
        super().__init__()
        self.entry = entry
        self.api_key = api_key
        self.signals = WorkerSignals()
    
    def run(self):
        try:
            # LLM評価の実行
            result = self._evaluate_translation()
            self.signals.result.emit(result)
        except Exception as e:
            self.signals.error.emit(str(e))
        finally:
            self.signals.finished.emit()
